## Introduction

This article assumes some prior familiarity with the randomizer.

When Hollow Knight's Randomizer 2 was first released, state logic would have been completely unnecessary. Back then, logic for every location was written painstakingly in terms of every manner to reach that part of the world from the start of the game in King's Pass. As Randomizer 2 developed into Randomizer 3, and start locations and room transitions became randomizable, more and more indirection had to be used in logic to make things still work. The result is that the logic became *relative*--instead of just listing combinations of items to unlock a location, it started to list combinations of items, along with points of the world that had to be "reachable". A location in King's Pass which previously had logic which always evaluated true, now had logic which evaluated true when King's Pass was "reachable", which might be always if the game started in King's Pass, but might mean something very different if the game started elsewhere.

One problem with this system is that "reachable" may not have a single clear definition. In Hollow Knight, different paths to the same location may require equipping different charms, spending soul (MP), or taking damage. To get around this originally, we wrote the randomizer logic with very stringent restrictions on "nonterminal" logic: basically, we required transitions and waypoints to never make those kinds of decisions. Only "terminal" logic, meaning logic for actual locations, could require charms or soul or anything along those lines. In practice, these guidelines were overly limiting and had to be repeatedly broken.

The purpose of state logic is to give a way to represent conditional reachability, rather than a single true/false value. States can represent consumable resources, equipment which can't be swapped out in certain locations, and other types of decisions which might be made on a path-dependent basis. In what follows, some of the basic concepts of state logic are explored, including what exactly RandomizerCore allows in a state and how they can be created and modified using logic.

## State Mechanics

The State class consists of a collection of Bool values and a collection of Int values. These fields are accessed through IDs which can be retrieved by name (as StateFields) in the StateManager, which is attached to the LogicManager.

The most important aspect of State is its ordering. First, the type Bool is totally ordered by false < true, and the type Int is totally ordered by its usual ordering. Then, State is *partially* ordered by the ordering on each of its fields. That is, for two states s1 and s2, we have s1 <= s2 if and only if for every state field f, s1.f <= s2.f. This is very important, because when the randomizer determines that a list of states can access a location, it reduces the list by removing states which are not minimal in the list with respect to the partial order.

The StateUnion class represents a collection of states which have been reduced by the process above. In other words, the states in a StateUnion are always pairwise incomparable with respect to the partial order, and a StateUnion is formed from a list of states by discarding states which compare as greater or equal to some other state in the list. Generally speaking, State should be interpreted as a particular combination of resources, and StateUnion should be interpreted as an alternative of possible states. StateUnion has two special values. A null StateUnion represents nonaccessibility. An empty StateUnion represents indeterminate (or minimum) accessibility. This notion is useful for example when randomizing transitions: for a given target transition, until its source is known, its state is unknown. By giving it the empty StateUnion, it can succeed at trivial state checks, though not nontrivial state checks. When the transition is finally placed at a source, the ILocationDependentItem implementation of RandoTransition or LogicTransition updates the state of the target to include the state of its source.

## State Logic

The StateLogicDef class is the base class for logic defs which support state calculations. DNFLogicDef is the RandomizerCore implementation of StateLogicDef.

Before evaluating state logic, the logic has to be put in disjunctive normal form. What this means is that all nested "or" operations are expanded out, so that the expression becomes an "or" of subexpressions which only contain "and" (a disjunction of conjunctions). For example, the disjunctive normal form of "A + (B | (C + D) | E)" is "(A + B) | (A + C + D) | (A + E)". The state modifiers in each conjunction then act sequentially left-to-right to perform state modifications. For more information, see the article on [implementing state logic](state_adv.md).