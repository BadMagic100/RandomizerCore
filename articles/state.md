## Introduction

This article assumes some prior familiarity with the randomizer.

When Hollow Knight's Randomizer 2 was first released, state logic would have been completely unnecessary. Back then, logic for every location was written painstakingly in terms of every manner to reach that part of the world from the start of the game in King's Pass. As Randomizer 2 developed into Randomizer 3, and start locations and room transitions became randomizable, more and more indirection had to be used in logic to make things still work. The result is that the logic became *relative*--instead of just listing combinations of items to unlock a location, it started to list combinations of items, along with points of the world that had to be "reachable". A location in King's Pass which previously had logic which always evaluated true, now had logic which evaluated true when King's Pass was "reachable", which might be always if the game started in King's Pass, but might mean something very different if the game started elsewhere.

One problem with this system is that "reachable" may not have a single clear definition. In Hollow Knight, different paths to the same location may require equipping different charms, spending soul (MP), or taking damage. To get around this originally, we wrote the randomizer logic with very stringent restrictions on "nonterminal" logic: basically, we required transitions and waypoints to never make those kinds of decisions. Only "terminal" logic, meaning logic for actual locations, could require charms or soul or anything along those lines. In practice, these guidelines were overly limiting and had to be repeatedly broken.

The purpose of state logic is to give a way to represent conditional reachability, rather than a single true/false value. States can represent consumable resources, equipment which can't be swapped out in certain locations, and other types of decisions which might be made on a path-dependent basis. In what follows, some of the basic concepts of state logic are explored, including what exactly RandomizerCore allows in a state and how they can be created and modified using logic.

## State Mechanics

The State class consists of a collection of Bool values and a collection of Int values. These fields are accessed through IDs which can be retrieved by name (as StateFields) in the StateManager, which is attached to the LogicManager.

The most important aspect of State is its ordering. First, the type Bool is totally ordered by false < true, and the type Int is totally ordered by its usual ordering. Then, State is *partially* ordered by the ordering on each of its fields. That is, for two states s1 and s2, we have s1 <= s2 if and only if for every state field f, s1.f <= s2.f. This is very important, because when the randomizer determines that a list of states can access a location, it reduces the list by removing states which are not minimal in the list with respect to the partial order.

The StateUnion class represents a collection of states which have been reduced by the process above. In other words, the states in a StateUnion are always pairwise incomparable with respect to the partial order, and a StateUnion is formed from a list of states by discarding states which compare as greater or equal to some other state in the list. Generally speaking, State should be interpreted as a particular combination of resources, and StateUnion should be interpreted as an alternative of possible states. StateUnion has two special values. A null StateUnion represents nonaccessibility. An empty StateUnion represents indeterminate (or minimum) accessibility. This notion is useful for example when randomizing transitions: for a given target transition, until its source is known, its state is unknown. By giving it the empty StateUnion, it can succeed at trivial state checks, though not nontrivial state checks. When the transition is finally placed at a source, the ILocationDependentItem implementation of RandoTransition or LogicTransition updates the state of the target to include the state of its source.

When adding a state field, it is essential to carefully consider how it will interact with the State ordering. For example, by default, state bools default to false, and can be set true. This is ideal for representing a consumable resource which one starts with, and can be spent once. States which have spent the resource will be discarded if there is a strictly better alternative which has not spent the resource. On the other hand, to represent a resource which one does not start with, but can be obtained once later, the state bool should be created to default to true, and be set false once the resource is obtained, so that states with the resource will not be pruned.

## State Logic

The StateLogicDef class is the base class for logic defs which support state calculations. DNFLogicDef is the RandomizerCore implementation of StateLogicDef.

Before evaluating state logic, the logic has to be put in disjunctive normal form. What this means is that all nested "or" operations are expanded out, so that the expression becomes an "or" of subexpressions which only contain "and" (a disjunction of conjunctions). For example, the disjunctive normal form of "A + (B | (C + D) | E)" is "(A + B) | (A + C + D) | (A + E)".

State logic can be evaluated on conjunctions as follows. First, the StateUnion input must be determined. This is the first term in the conjunction which is a simple state-valued term, or a LogicVariable which subclasses StateProviderVariable. So, speaking generally, if logic is written relative to waypoints, the first state-valued waypoint in a conjunction provides its input state, and if logic is written relative to transitions, the first transition in a conjunction provides its input state. Generally, the use of StateProviderVariables is for exceptional cases where a logic branch requires a new state; the only StateProviderVariable currently included in RandomizerCore is StartStateProvider, denoted in logic by "$START" which provides the default state. Once the input is determined, for each of its states, each state modifier runs in sequence on the output of the previous. Doing this for each conjunction in the disjunctive normal form produces a list of states as a result, which can be put into a StateUnion.

## State Modifiers

State can be modified directly in logic by creating LogicVariables to do specific modifications. RandomizerCore supports two base classes for such operations. StateModifyingVariable is a base class for state modifiers which take an input state to 0 or 1 output states. StateSplittingVariable is a base class for state modifiers which take an input state to 0 or more output states.

State logic is evaluated in two different ways: as a LogicDef, to produce a bool result, and as a StateLogicDef, to produce a state result. It is essential that these two evaluations agree: that is, the bool result should not return true if the state result would be empty, and vice versa. StateModifyingVariable and StateSplittingVariable provide default implementations for the bool result in terms of the state result, to ensure this. However, those implementations are relatively inefficient, since they may require creating and modifying extra states, even though the state result is not needed, so one can override them with a more specific implementation for better performance.

The most common reason why the bool result may diverge from the state result is if a conjunction contains multiple state modifiers which modify the same state field. During bool evaluation, the state modifiers do not modify the state, so they cannot share information, whereas they operate sequentially on the state in the other mode of evaluation. To avoid this issue, one can use the StateModifierConjunction, which is matched by the pattern "$STCONJ[SV0,SV1,...,SVN]" in logic. Here, "SV0" and so on should be replaced with the term for the state variable argument in question. The conjunction handles bool evaluation by having each of its state modifiers modify the state in sequence, so that information is properly shared. As a result, the conjunction is again relatively inefficient, but easily deployed. One can create an implementation for combining specific state modifiers for better performance.

## Integration with the ProgressionManager and MainUpdater

When evaluating bool logic, all terms are interpreted as int-valued. The int value of a state-valued term is 0 if its state is null, and 1 otherwise. This is the value returned by pm.Get(id) if id is the id of a state-valued term, and the value used for derived computations such as pm.Has, etc. Use pm.GetState to retrieve the full StateUnion associated with the term.

The MainUpdater automatically manages logic-derived state updates for state-valued waypoints and transitions. Use mu.AddManagedStates to give a state-valued term logic-derived state updates. Often, the effect of an item may be to trigger an ongoing state modification. This can be done by modifying the MainUpdater attached to the ProgressionManager. If the state effect depends on the item's location, this can further be done within an ILocationDependentItem implementation for the item.